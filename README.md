# SoftwareTesting
The program uploaded here contains several classes used to create services that locally store contact, task, and appointment details. Each class is tested using JUnit tests to ensure that all methods have 100% coverage before deployment.

To ensure the software is functional and secure, it truly starts with the requirements of the client. While some security standards can be universal, it is critical to understand the client's security needs so proper measures can be taken to ensure the safety of data and system integrations. When the requirements have been specified, testing plans can be created to ensure the requirements have been fully met before release. High-quality tests can be used for checking security requirements and functional requirements. They should include static testing, testing completed through visual inspection of the program, and dynamic testing, testing completed through the execution of the program. Static tests can be beneficial for identifying inconsistencies, structural defects, and deviations from standards. Dynamic tests can identify performance issues and non-functional requirements. Dynamic testing can be done through automated tests, such as JUnit tests. While Automated tests can have a large upfront time investment, they can lead to faster turnaround of releases after they are developed. 

When I design software, I start by listing the requirements of the client. I find the most efficient way of communicating requirements to be through a face-to-face meeting. This meeting can take a long time, so I always enter the meeting prepared with questions, ideas, and recommendations. After the meeting, I create several preliminary design documents that include all requirements decided upon in the initial meeting and send this to the client for approval. Upon approval, I create development plans and testing plans based on the finalized requirements. Sometimes during development, I need to reach out to the client with a recommendation for modifying a requirement due to unforeseen implications that come with development and testing. This is often something along the lines of a performance compromise that needs to be made. I work with the client to come to a resolution they are satisfied with and finish out the development, using static testing and some dynamic unit testing along the way to make sure most mistakes are taken care of early in the development cycle. After development, I implement the testing plans created from the requirements. I start with a full set of static tests and then use dynamic testing and automated unit tests to ensure full testing coverage of the program. When all corrections have been implemented, and I am ready to hand them off to the client, I schedule a site acceptance test and factory acceptance test with them and complete all final tests with the client present. 
